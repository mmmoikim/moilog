---
date: 2021-04-26
---

# 타입스크립트 프로그래밍

### 컴파일러

1. 자바스크립트 소스 추상문법트리AST로 파싱
2. 바이트코드로 변환
3. 런타임이 바이트 코드를 평가

런타임 : 다른 프로그램에 바이트코드를 입력해 평가하고 결과를 얻을 수 있음

### 타입 스크립트

1. 타입스크립트 소스 - 타입스크립트 AST
2. 타입 검사기가 AST를 확인
3. 타입스크립트 AST - 자바스크립트 소스

타입검사기 : 코드의 타입 안정성을 검증하는 프로그램

개발자가 코드에 기입한 타입정보는 최종적으로 만들어지는 프로그램에 아무 영향을 주지 않는다!

### 타입 시스템

1. 명시적으로 알려주는 타입 시스템
2. 자동으로 추론하는 시스템

- 타입 스크립트는 두가지 모두 영향을 받아 명시할 수도, 추론하도록 할 수 도 있음

- 추론은 코드를 줄일 수 있는 방법

- 동적 타입 바인딩 : 프로그램을 실행해야만 타입을 알 수 있음

- 타입스크립트는 점진적으로 타입을 확인하는 언어, 모든 타입을 알아야 하는 것은 아니다.

- 올바르지 않아 보이는 연산은 의도적으로 명시를 해야 한다

- 자바스크립트는 런타임에 예외를 던지거나 암묵적인 형변환을 수행

- 타입스크립트는 컴파일 타임에 검출 할 수 있다는 것이 핵심!

- any : 꼭 필요한 상황이 아니라면 사용하지 않는 것이 좋다.

- unkown : 타입을 정제 하기 전까지 값을 쓸 수 없음

- 타입리터럴 : 오직 하나의 값을 나타내는 타입

`let e : true = true;`

- 숫자 분리자

`1_000_000 // 1000000과 같음`

- bigint: number 253보다 더 큰 정수를 처리 할 수 있다. 플랫폼 지원 하는지 확인 필요

- symbol : Symbol('a') 주어진 이름으로 새로운 심볼을 만듬, typeof a, const 에 할당하면 unique 심볼로 추론

`let g : unique symbol`

- {}와 new로 만든 객체를 구분 할 수 없다, 자바스크립트는 구조기반타입을 쓰기 때문, 객체가 어떤 프로퍼티를 갖고 있는지를 따짐, 이름기반 타입에서는 이름을 따진다

- object 타입은 애니보다 조금 더 좁은 타입, 자바스크립트의 객체일 뿐이라고 알려준다

- 객체리터럴 문법, 객체는 const로 선언해도 조금 좁은 타입으로 추론 하지 않는다.

- 빈객체타입은 null과 undefined를 제외한 모든 타입이 할당 될 수 있기때문에 피하는 것이 좋다  let danger : {}

- Object타입, 빈객체와 비슷하다, 사용하지 않는 것이 좋다,빈객체 타입과 다른점은 object의 프로토타입 내장메서드를 정의 할 수 없음, tostring

- 타입 별칭은 블록스코프에서 덮어 쓸 수 있다.
```
type Color = 'red'
if(){
    type Color = 'blue'
}
```
### 튜플

- 최소 한개의 string을 갖는 배열

`let array : [string, ...string[]] `

- 배열을 안전하게 관리하고 배열 타입의 길이도 조절, 순수 배열보다 안전성을 높일 수 있다.

### enum

- enum은 역방향찾기, 키값으로 접근하지 못하도록 const enum로 막을 수 있다. Language[0]

- argument는 애니로 추론하기 때문에 가변인자를 사용할때는 (...numbers : number[])

### 제너레이터함수

- 여러개의 값을 생성할 수 있다, 값을 생성하는 속도 조절

- 제너레이터 함수는 이터러블 반복자를 반환

- 영구적으로 값을 생성 할 수 있음.

- yield라는 키워드로 값을 방출

- next로 소비

- 반복자 iteator

- 제너레이터로 스트림을 생성하고 반복자로 소비 next

### 호출 시그니쳐

- 호출 시그니쳐 : 타입 수준 코드, 타입 정보만 포함

- type Greate = (name : string) ⇒ string;

- 구체타입 : 기대하는 타입을 정확하게 알 고 있을때

- 제네릭 : 플레이스홀더타입, 다형성 타입 매개변수

- 호출 시그니쳐에 제네릭으로 선언하고, 호출할 때 타입을 명시적으로 한정

`type Filter<T> = {(array : T[], f : (item:T)→ boolean): T[])`

- 타입 주도 개발 : 타입 시그니쳐를 먼저 정하고 값을 나중에 채우는 방식